---
layout: post  
title:  "从VIP内部sonar检测结果看常见代码问题--持续更新"  
date:   2019-03-22 01:20  
categories: java  
permalink: /Priest/VIP-sonar-code

---

## 前言  
项目稳定之后，开始逐步关注过去赶进度写的“坏”代码问题，唯品会内部订制的sonar检测规则，在每次上线的时候都会进行静态代码检查，这阵子抽空看了自己项目的代码问题，同时也看了很多别的项目的检测结果，还是挺有收获，记录下。  

## 代码细节
**1.boxed and unboxed**  
拆箱跟装箱，是在sonar检测结果中见过最多的，正如sonar所提示 **Be aware that this boxing happens automatically when you might not expect it.** 很多没必要的装箱拆箱操作都是在你无意间发生的。比如：  
```
Long data = Long.parseLong("123");
```

Long.parseLong(XXX) 返回的是long，而结果声明的是Long，所以无意间又触发了装箱  
同样，反过来的有valueOf方法  
```
long data = Long.valueOf("123");
```

这个问题是在看了几个项目的sonar结果中最常见的一个，比较多的场景是在用到方法调用参数上，例如方法的参数声明为 long, 而调用的时候是传Long，这样不仅有拆箱的操作，而且有NPE的可能性。  

**2.Files.newInputStream(myfile.toPath()) and new FileInputStream**  
创建FileInputStream对象，在使用new FileInputStream方式中，FileInputStream实现了finalize方法，这意味着创建的对象可能会一直挂起，直到发生gc，这意味着该对象在堆上的垃圾过多的时间更长。在java 7 中提供了NIO方式去创建，  
```
InputStream is = java.nio.file.Files.newInputStream(myfile.toPath()); 
```
该方法返回的是 new sun.nio.ch.ChannelInputStream, ChannelInputStreamm没有实现finalize方法，就不会有上面那种问题。类似的还有FileOutputStream  

**3.**
